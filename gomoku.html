<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <!-- ç¶²é æ¨™é¡Œèˆ‡æè¿° (åˆ†äº«é€£çµæ™‚æœƒé¡¯ç¤º) -->
  <title>äº”å­æ£‹ Gomoku - é‚è¼¯å°æˆ°éŠæˆ²</title>
  <meta name="description" content="å…å®‰è£ã€é›¢ç·šå¯ç©çš„äº”å­æ£‹éŠæˆ²ã€‚æ”¯æ´å–®äººæŒ‘æˆ° AI æˆ–é›™äººåŒæ©Ÿå°æˆ°ã€‚">
  
  <!-- Open Graph / Facebook / LINE åˆ†äº«é è¦½è¨­å®š -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="äº”å­æ£‹ Gomoku - æŒ‘æˆ°ä½ çš„å¤§è…¦">
  <meta property="og:description" content="éš¨æ™‚éš¨åœ°ï¼Œæ‰“é–‹ç€è¦½å™¨å°±èƒ½ç©ï¼æ”¯æ´é›»è…¦å°æˆ°èˆ‡é›™äººæ¨¡å¼ã€‚">
  <!-- å¦‚æœæ‚¨æœ‰æˆªåœ–ï¼Œå¯å°‡åœ–ç‰‡ä¸Šå‚³åˆ° GitHub ä¸¦å°‡é€£çµå¡«å…¥ä¸‹æ–¹ content -->
  <meta property="og:image" content=""> 

  <!-- iOS PWA æ”¯æ´ -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    :root {
      --bg-main: #f8fafc;
      --text-main: #1e293b;
      --board-bg: #cbd5e1; /* æ£‹ç›¤ç·šæ¢é¡è‰²åŠ æ·±ä¸€é» */
      --cell-bg: #f1f5f9;   /* æ£‹ç›¤èƒŒæ™¯è‰² */
      --black-piece: #0f172a;
      --white-piece: #ffffff;
      --white-border: #94a3b8;
      --highlight: #ef4444; 
      --win-green: #dcfce3;
      --win-text: #166534;
      --shadow-color: rgba(0, 0, 0, 0.1);
    }
    
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background-color: var(--bg-main);
      color: var(--text-main);
      margin: 0;
      padding: 20px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      /* é˜²æ­¢æ‰‹æ©Ÿå‘ä¸‹æ‹‰å‹•é‡æ–°æ•´ç† */
      overscroll-behavior-y: none;
    }

    .container {
      max-width: 500px;
      width: 100%;
    }

    /* é ­éƒ¨èˆ‡é¸å–® */
    .header { margin-bottom: 20px; }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .title {
      font-size: 26px;
      font-weight: 800;
      margin: 0;
      letter-spacing: 1px;
      color: #334155;
    }

    .subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 4px 0 0;
    }

    .settings-row {
      display: flex;
      gap: 10px;
    }

    select {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #cbd5e1;
      font-size: 15px;
      outline: none;
      background: white;
      cursor: pointer;
      flex: 1;
      color: #334155;
      appearance: none; /* ç§»é™¤é è¨­ç®­é ­ï¼Œå¯è‡ªè¨‚ä½†é€™è£¡ä¿æŒç°¡å–® */
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23334155%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 12px top 50%;
      background-size: 10px auto;
    }

    /* ç‹€æ…‹é¡¯ç¤ºæ¢ */
    .status-bar {
      background: white;
      padding: 12px 16px;
      border-radius: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      box-shadow: 0 2px 4px var(--shadow-color);
      font-weight: 600;
      font-size: 15px;
    }

    .turn-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mini-piece {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .mini-black { background: var(--black-piece); }
    .mini-white { background: var(--white-piece); border-color: var(--white-border); }

    /* å‹åˆ©æç¤º */
    .alert-win {
      background: var(--win-green);
      border: 1px solid #86efac;
      color: var(--win-text);
      padding: 14px;
      border-radius: 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      font-weight: bold;
      animation: bounce 1s infinite;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    }
    .hidden { display: none !important; }

    @keyframes bounce {
      0%, 100% { transform: translateY(-5%); }
      50% { transform: none; }
    }

    /* æ£‹ç›¤å€åŸŸ */
    .board-container {
      background: #e2e8f0; /* å¤–æ¡†åº•è‰² */
      padding: 6px;
      border-radius: 8px;
      box-shadow: 0 10px 20px -5px rgba(0,0,0,0.15);
      margin-bottom: 24px;
      position: relative;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(15, 1fr);
      gap: 1px;
      background: var(--board-bg);
      border: 2px solid var(--board-bg); /* å¤–åœç·šæ¢ */
      aspect-ratio: 1 / 1;
      border-radius: 4px;
      overflow: hidden;
    }

    .cell {
      background: var(--cell-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      /* é»æ“Šå„ªåŒ– */
      touch-action: manipulation;
    }

    /* æ£‹å­æ¨£å¼ */
    .piece {
      width: 82%;
      height: 82%;
      border-radius: 50%;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      transform: scale(0);
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); /* æ›´æœ‰å½ˆæ€§çš„å‹•ç•« */
    }
    
    .piece.show { transform: scale(1); }
    
    .piece.black { 
      background: radial-gradient(circle at 35% 35%, #475569, #020617); 
    }
    
    .piece.white { 
      background: radial-gradient(circle at 35% 35%, #ffffff, #cbd5e1);
      border: 1px solid #94a3b8;
    }

    /* æœ€å¾Œä¸€æ‰‹çš„æ¨™è¨˜ - æ”¹ç‚ºç´…è‰²åœ“é»åœ¨æ£‹å­ä¸Šæ–¹ */
    .last-move::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 25%;
      height: 25%;
      background-color: var(--highlight);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(239, 68, 68, 0.8);
      z-index: 5;
    }

    /* æ§åˆ¶æŒ‰éˆ• */
    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
    }

    .btn {
      flex: 1;
      padding: 14px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: all 0.1s;
      border: none;
    }

    .btn-primary {
      background: #2563eb;
      color: white;
      box-shadow: 0 4px 6px rgba(37, 99, 235, 0.25);
    }
    .btn-primary:active { transform: scale(0.96); background: #1d4ed8; }

    .btn-secondary {
      background: white;
      color: #334155;
      border: 1px solid #cbd5e1;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .btn-secondary:active { transform: scale(0.96); background: #f1f5f9; }

    /* æç¤ºå€å¡Š */
    .info-box {
      background: #f1f5f9;
      padding: 16px;
      border-radius: 12px;
      display: flex;
      gap: 12px;
      font-size: 14px;
      color: #64748b;
      line-height: 1.5;
    }
    .info-icon { flex-shrink: 0; color: #94a3b8; }

  </style>
</head>
<body>

  <div class="container">
    <header class="header">
      <div class="header-top">
        <div>
          <h1 class="title">äº”å­æ£‹ Gomoku</h1>
          <p class="subtitle">é€£æˆäº”å­å³å¯ç²å‹</p>
        </div>
      </div>
      
      <div class="settings-row">
        <select id="mode-select" onchange="toggleDifficulty()">
          <option value="pvc">å–®äºº vs é›»è…¦</option>
          <option value="pvp">é›™äººå°æˆ° (åŒè£ç½®)</option>
        </select>
        
        <select id="difficulty-select">
          <option value="easy">ç°¡å–® (éš¨æ©Ÿ)</option>
          <option value="normal" selected>æ™®é€š (é˜²å®ˆ)</option>
          <option value="hard">å›°é›£ (æŒ‘æˆ°)</option>
        </select>
      </div>
    </header>

    <!-- ç‹€æ…‹åˆ— -->
    <div class="status-bar">
      <div class="turn-indicator" id="turn-text">
        <div class="mini-piece mini-black"></div>
        <span>è¼ªåˆ°é»‘æ£‹</span>
      </div>
      <div id="game-status" style="color: #64748b; font-size: 14px;">éŠæˆ²é€²è¡Œä¸­</div>
    </div>

    <!-- å‹åˆ©/çµæŸæç¤º -->
    <div id="win-message" class="alert-win hidden">
      <!-- JS å‹•æ…‹å¡«å…¥ -->
    </div>

    <!-- æ£‹ç›¤ -->
    <div class="board-container">
      <div id="gomoku-board" class="board">
        <!-- JS ç”Ÿæˆ 15x15 -->
      </div>
    </div>

    <!-- æ§åˆ¶æŒ‰éˆ• -->
    <div class="controls">
      <button onclick="startNewGame()" class="btn btn-primary">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="6 3 20 12 6 21 6 3"/></svg>
        æ–°éŠæˆ²
      </button>
      <button onclick="undoMove()" class="btn btn-secondary" id="btn-undo">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
        æ‚”æ£‹
      </button>
    </div>
    
    <!-- èªªæ˜ -->
    <div class="info-box">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" class="info-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
      <div>
        <strong>ç©æ³•ï¼š</strong> é»‘æ£‹å…ˆæ‰‹ã€‚ä»»ä¸€æ–¹åœ¨æ©«ã€ç›´ã€æ–œæ–¹å‘é€£æˆ 5 å€‹åŒè‰²æ£‹å­å³ç²å‹ã€‚<br>
        <span style="font-size: 12px; color: #94a3b8; margin-top: 4px; display: block;">è‹¥è¦åˆ†äº«çµ¦æœ‹å‹ï¼Œè«‹é»æ“Šç€è¦½å™¨çš„ã€Œåˆ†äº«ã€æŒ‰éˆ•ã€‚</span>
      </div>
    </div>
  </div>

  <script>
    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = 2;

    let board = [];
    let currentPlayer = BLACK;
    let isGameActive = false;
    let gameMode = 'pvc';
    let difficulty = 'normal';
    let moveHistory = []; 
    let isComputerThinking = false;

    function initBoard() {
      board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
    }

    function toggleDifficulty() {
      const mode = document.getElementById('mode-select').value;
      const diffSelect = document.getElementById('difficulty-select');
      diffSelect.style.display = (mode === 'pvp') ? 'none' : 'block';
    }

    function startNewGame() {
      gameMode = document.getElementById('mode-select').value;
      difficulty = document.getElementById('difficulty-select').value;
      
      initBoard();
      currentPlayer = BLACK;
      isGameActive = true;
      moveHistory = [];
      isComputerThinking = false;
      
      document.getElementById('win-message').classList.add('hidden');
      updateStatusUI();
      renderBoard();
    }

    function renderBoard() {
      const container = document.getElementById('gomoku-board');
      container.innerHTML = '';
      
      const lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;
          cell.onclick = () => handleCellClick(r, c);

          const val = board[r][c];
          if (val !== EMPTY) {
            const piece = document.createElement('div');
            piece.className = `piece ${val === BLACK ? 'black' : 'white'} show`;
            if (lastMove && lastMove.r === r && lastMove.c === c) {
              piece.classList.add('last-move');
            }
            cell.appendChild(piece);
          }
          container.appendChild(cell);
        }
      }
    }

    function updateStatusUI() {
      const turnText = document.getElementById('turn-text');
      const gameStatus = document.getElementById('game-status');
      
      if (!isGameActive) {
        gameStatus.textContent = "";
        return;
      }

      gameStatus.textContent = "éŠæˆ²é€²è¡Œä¸­";
      const dot = turnText.querySelector('.mini-piece');
      const span = turnText.querySelector('span');
      
      if (currentPlayer === BLACK) {
        dot.className = 'mini-piece mini-black';
        span.textContent = "è¼ªåˆ°é»‘æ£‹";
      } else {
        dot.className = 'mini-piece mini-white';
        span.textContent = "è¼ªåˆ°ç™½æ£‹";
      }
      
      if (gameMode === 'pvc' && currentPlayer === WHITE) {
        span.textContent = "é›»è…¦æ€è€ƒä¸­...";
      }
    }

    function handleCellClick(r, c) {
      if (!isGameActive || board[r][c] !== EMPTY || isComputerThinking) return;
      
      // ç°¡å–®çš„é˜²å‘†ï¼Œé˜²æ­¢å¿«é€Ÿé»æ“Š
      if (gameMode === 'pvc' && currentPlayer === WHITE) return;

      makeMove(r, c, currentPlayer);

      if (checkWin(r, c, currentPlayer)) {
        endGame(currentPlayer);
        return;
      }
      if (moveHistory.length === BOARD_SIZE * BOARD_SIZE) {
        endGame(0);
        return;
      }

      switchTurn();
    }

    function makeMove(r, c, player) {
      board[r][c] = player;
      moveHistory.push({ r, c, player });
      
      const cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);
      if (cell) {
        const oldLast = document.querySelector('.last-move');
        if (oldLast) oldLast.classList.remove('last-move');

        const piece = document.createElement('div');
        piece.className = `piece ${player === BLACK ? 'black' : 'white'} last-move`;
        requestAnimationFrame(() => piece.classList.add('show'));
        cell.appendChild(piece);
      }
    }

    function switchTurn() {
      currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
      updateStatusUI();

      if (gameMode === 'pvc' && currentPlayer === WHITE && isGameActive) {
        isComputerThinking = true;
        setTimeout(computerMove, 500); 
      }
    }

    function undoMove() {
      if (!isGameActive && !document.getElementById('win-message').classList.contains('hidden')) return;
      if (moveHistory.length === 0 || isComputerThinking) return;

      let steps = (gameMode === 'pvc') ? 2 : 1;
      if (gameMode === 'pvc' && currentPlayer === WHITE) steps = 1; 

      while (steps > 0 && moveHistory.length > 0) {
        const last = moveHistory.pop();
        board[last.r][last.c] = EMPTY;
        steps--;
      }

      if (moveHistory.length > 0) {
        const last = moveHistory[moveHistory.length - 1];
        currentPlayer = last.player === BLACK ? WHITE : BLACK;
      } else {
        currentPlayer = BLACK;
      }

      isGameActive = true;
      document.getElementById('win-message').classList.add('hidden');
      renderBoard(); 
      updateStatusUI();
    }

    function endGame(winner) {
      isGameActive = false;
      const winMsg = document.getElementById('win-message');
      winMsg.classList.remove('hidden');
      
      if (winner === BLACK) {
        winMsg.innerHTML = '<span>ğŸ† é»‘æ£‹ç²å‹ï¼</span>';
        winMsg.style.background = '#dcfce3';
        winMsg.style.color = '#166534';
      } else if (winner === WHITE) {
        winMsg.innerHTML = '<span>ğŸ† ç™½æ£‹ç²å‹ï¼</span>';
        winMsg.style.background = '#dcfce3';
        winMsg.style.color = '#166534';
      } else {
        winMsg.innerHTML = '<span>ğŸ¤ é›™æ–¹å’Œå±€ï¼</span>';
        winMsg.style.background = '#f1f5f9';
        winMsg.style.color = '#334155';
      }
      document.getElementById('game-status').textContent = "éŠæˆ²çµæŸ";
    }

    const DIRS = [[1, 0], [0, 1], [1, 1], [1, -1]];

    function checkWin(r, c, player) {
      for (let [dr, dc] of DIRS) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
          const nr = r + dr * i;
          const nc = c + dc * i;
          if (isValidPos(nr, nc) && board[nr][nc] === player) count++;
          else break;
        }
        for (let i = 1; i < 5; i++) {
          const nr = r - dr * i;
          const nc = c - dc * i;
          if (isValidPos(nr, nc) && board[nr][nc] === player) count++;
          else break;
        }
        if (count >= 5) return true;
      }
      return false;
    }

    function isValidPos(r, c) {
      return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
    }

    function computerMove() {
      if (!isGameActive) return;

      let bestScore = -Infinity;
      let bestMoves = [];

      if (moveHistory.length === 1) {
        const center = Math.floor(BOARD_SIZE / 2);
        // ç¬¬ä¸€æ‰‹å¦‚æœæ˜¯å¤©å…ƒé™„è¿‘ï¼Œéš¨æ©Ÿæ‡‰å°
        const r = center + (Math.random() > 0.5 ? 1 : -1);
        const c = center + (Math.random() > 0.5 ? 1 : -1);
        // ç¢ºä¿ä¸é‡ç–Š
        if(board[r][c] === EMPTY) {
            makeMove(r, c, WHITE);
            switchTurn();
            isComputerThinking = false;
            return;
        }
      }

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (board[r][c] === EMPTY) {
            if (!hasNeighbor(r, c)) continue;

            const score = evaluatePoint(r, c);
            if (score > bestScore) {
              bestScore = score;
              bestMoves = [{r, c}];
            } else if (score === bestScore) {
              bestMoves.push({r, c});
            }
          }
        }
      }

      if (bestMoves.length === 0) {
        // Fallback: æ‰¾ä»»ä½•ä¸€å€‹ç©ºä½
        for (let r = 0; r < BOARD_SIZE; r++) {
           for (let c = 0; c < BOARD_SIZE; c++) {
              if (board[r][c] === EMPTY) {
                 makeMove(r, c, WHITE);
                 switchTurn();
                 isComputerThinking = false;
                 return;
              }
           }
        }
        return;
      }

      const move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
      makeMove(move.r, move.c, WHITE);
      
      if (checkWin(move.r, move.c, WHITE)) {
        endGame(WHITE);
      } else if (moveHistory.length === BOARD_SIZE * BOARD_SIZE) {
        endGame(0);
      } else {
        switchTurn();
      }
      isComputerThinking = false;
    }

    function hasNeighbor(r, c) {
      for (let i = -2; i <= 2; i++) {
        for (let j = -2; j <= 2; j++) {
          if (i === 0 && j === 0) continue;
          const nr = r + i, nc = c + j;
          if (isValidPos(nr, nc) && board[nr][nc] !== EMPTY) return true;
        }
      }
      return false;
    }

    function evaluatePoint(r, c) {
      const attackScore = evaluateLine(r, c, WHITE);
      const defenseScore = evaluateLine(r, c, BLACK);
      let total = 0;

      if (difficulty === 'easy') {
        total = attackScore + defenseScore * 0.5 + Math.random() * 20;
      } else if (difficulty === 'normal') {
        // æ™®é€šï¼šå¦‚æœå°æ‰‹(é»‘)æœ‰é€£å››æˆ–æ´»ä¸‰ï¼Œé˜²å®ˆåˆ†æ•¸æœƒå¾ˆé«˜
        if (defenseScore >= 5000) return defenseScore + 500; 
        total = attackScore + defenseScore;
      } else {
        // å›°é›£
        if (attackScore >= 100000) return 999999; // å·±æ–¹èƒ½è´
        if (defenseScore >= 100000) return 800000; // å°æ–¹è¦è´
        // ç©æ¥µé€²æ”»
        total = attackScore * 1.3 + defenseScore;
      }
      return total;
    }

    function evaluateLine(r, c, player) {
      let score = 0;
      for (let [dr, dc] of DIRS) {
        let count = 1; 
        let block = 0;
        
        // æ­£å‘
        let i = 1;
        while (i <= 4) {
          const nr = r + dr * i;
          const nc = c + dc * i;
          if (!isValidPos(nr, nc)) { block++; break; }
          if (board[nr][nc] === player) { count++; }
          else if (board[nr][nc] === EMPTY) { break; } 
          else { block++; break; } 
          i++;
        }
        
        // åå‘
        i = 1;
        while (i <= 4) {
          const nr = r - dr * i;
          const nc = c - dc * i;
          if (!isValidPos(nr, nc)) { block++; break; }
          if (board[nr][nc] === player) { count++; }
          else if (board[nr][nc] === EMPTY) { break; }
          else { block++; break; }
          i++;
        }

        if (block === 2) {
          score += 0; 
        } else if (count >= 5) {
          score += 100000;
        } else if (count === 4) {
          if (block === 0) score += 10000; // æ´»å››
          else score += 1500; // è¡å››
        } else if (count === 3) {
          if (block === 0) score += 1000; // æ´»ä¸‰
          else score += 100; // æ­»ä¸‰
        } else if (count === 2) {
           if (block === 0) score += 100; // æ´»äºŒ
           else score += 10;
        } else if (count === 1) {
           score += 1;
        }
      }
      return score;
    }

    toggleDifficulty();
    startNewGame();
    
  </script>
</body>
</html>